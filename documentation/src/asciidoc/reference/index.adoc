= Yaktor Reference Guide
:docVersion: 0.1.0
:idprefix:
:idseparator: -
:yaktorNodeDockerTag: 0.39.0
:nodejs: link:http://nodejs.org[Node.js^]
:springroo: link:http://projects.spring.io/spring-roo[Spring Roo^]
:docker: link:https://www.docker.com[Docker^]
:stackoverflow: link:http://www.stackoverflow.com[Stack Overflow^]
:gitter: link:https://gitter.im/SciSpike/yaktor[Gitter^]
:spring: link:http://spring.io[Spring^]
:npm: link:http://npmjs.org[npm^]
:mongodb: link:https://www.mongodb.com[MongoDB^]
:cassandra: link:http://cassandra.apache.org[Cassandra^]
:eclipseplugin: link:http://yaktor.io/eclipse[eclipse plugin^]
:javascript: link:http://www.ecma-international.org/publications/standards/Ecma-262.htm[JavaScript^]
:express: link:http://expressjs.com[Express^]
:mongoose: link:http://mongoosejs.com/[Mongoose^]
:springboot: link:http://spring.io/projects/spring-boot[Spring Boot^]
:akka: link:http://akka.io[Akka^]
:scala: link:http://scala-lang.org[Scala^]
:java: link:http://www.java.com[Java^]

*Authors*: Petter Graff, Jonathan Kamke, Barrett Cervenka, Matthew Adams

_Version: {docVersion}, Last Updated: {docdatetime}_

== Part I. Metadocumentation
This section provides a brief overview of the Yaktor reference documentation.

=== About
This reference guide is available in source form in Github at
https://github.com/SciSpike/yaktor-docs/blob/master/documentation/src/asciidoc/reference/index.adoc
or on the Yaktor docs site at http://yaktor.io.

=== Getting help
If you need help with Yaktor, it's available.

* Try the FAQs (TODO) for answers to the most common questions.
* Ask questions with the tag `yaktor` on {stackoverflow}.
* Discuss Yaktor at {gitter}.
(Yaktor committer hours vary but are generally U.S. business hours.)

=== First steps
* <<requirements>> | <<installation>>
* Tutorials (TODO)

=== Working with Yaktor
Ready to start working with Yaktor? Then <<writing-code,write some code>>!

== Part II. Getting Started
This section aims to quickly get you up & running with Yaktor using its {nodejs} mapping.

=== tl;dr

Install {docker} 1.11 or later, then create a new or work on an existing Yaktor application.

[cols="2", options="header"]
|===
^| New Application ^| Existing Application

a|
[source,sh,options="nowrap",subs="attributes+"]
----
$ mkdir myapp && cd myapp                        <1>
$ docker run -it --rm --user node \
  -v "$PWD":/app --entrypoint bash \
  yaktor/node:{yaktorNodeDockerTag} -c \
  'npm install yaktor && $(npm bin)/yaktor init' <2>
$ ./yak gen-src gen-views start                  <3>
----
<1> Create & change into new app directory
<2> Initialize Yaktor application (alias this?)
<3> Generate source & views then start app

a|
[source,sh,options="nowrap"]
----
$ git clone ...                 <1>
$ cd ...                        <2>
$ ./yak gen-src gen-views start <3>
----
<1> Get source
<2> Change into source directory
<3> Generate source & views then start app
|===

To see the generated application UI, open http://www.yakapp.yaktor in a browser.

=== Introducing Yaktor
Yaktor is a tool to assist in the rapid creation of highly scalable, event-driven, agent-based applications.
It leverages domain-specific languages (DSLs) that decouple much of the business logic from the actual implementation technology.
In this way, your application is future-proofed against changes in technology; as new technologies & patterns emerge, the Yaktor team (or your team) can define new Yaktor mappings to generate code according to each technology's syntax & best practices.

IMPORTANT: Although Yaktor includes a code generator, it has been carefully designed to preserve any code customizations you make.

Yaktor was originally prototyped with a {springroo} mapping, so it supported {spring}-based {java} technology.
The {springroo} mapping was later abandoned in favor of using {nodejs} and its {npm}-based ecosystem.
Yaktor's {nodejs} mapping is currently the primary (and only) supported mapping.
The Yaktor team is considering other mappings, including {springboot}-based {java}, {akka}/{scala}, and others.

Yaktor leverages a feature-based design.
The Yaktor team has authored features that can be added to existing Yaktor-based applications.
For example, if your Yaktor {nodejs} application needs authentication & authorization, you can use link:https://github.com/SciSpike/yaktor-auth[`yaktor-auth`] to add those features.
Other development teams can add other Yaktor features as well.

=== Requirements
There are two ways that you can run Yaktor applications:

* by <<using-docker,using Docker>>, our recommended approach, or
* by <<running-natively,installing all prerequisite software and running natively>> on your platform.

NOTE: The Yaktor team _strongly encourages_ you to use the Docker approach.
It eliminates many problems related to platform-specifics & dependencies, requiring almost no configuration aside from Docker itself.

==== Using Docker
The minimum requirement to use Yaktor with Docker is to have {docker} 1.11 or later installed.

NOTE: Yaktor is supported on *Docker Toolbox 1.11 with VirtualBox or Dlite*, or *Docker for Mac*, *Docker for Windows*, or *Docker for Linux* 1.12 or later.
Running Yaktor on prerelease or other versions of Docker may work but is unsupported.

Once you have Docker installed and configured for your environment, continue to <<installation>>.

==== Running Natively
The minimum requirements to run Yaktor applications natively on your platform include:

* {nodejs} 4.x or later
* {mongodb} 3.0.4 or later

Additional, optional dependencies include

* {cassandra} 2.1 or later (for event stream storage)

Make sure that you have these dependencies installed and configured for your environment, then continue to <<installation>>.

=== Installation
There are two types of Yaktor installations: <<installation-with-docker,Docker>> (recommended) & <<native-installation,native>>.

==== Installation with Docker
"Installation" with Docker is almost a misnomer, thanks to the beauty of Docker.
We've already prepared Docker images that contain all of Yaktor's requirements & dependencies.
If you've already gotten Docker installed & configured, then your Yaktor installation steps are complete.
Move on to <<writing-code,writing code>>!

==== Native installation
TODO: give pointers to installation instructions for dependent software here

=== Writing code
This section details how to get started authoring a Yaktor application.

==== Brand new Yaktor project
If you're using Docker to create a new Yaktor project, see <<new-yaktor-project-with-docker>>.

If you're running natively, see <<new-native-yaktor-application>>.

===== New Yaktor project with Docker
[source,sh,subs="attributes+"]
----
$ mkdir yakapp                                   <1>
$ cd yakapp                                      <2>
$ docker run -it --rm --user node \
  -v "$PWD":/app --entrypoint bash \
  yaktor/node:{yaktorNodeDockerTag} -c \
  'npm install yaktor && $(npm bin)/yaktor init' <3>
$ ./yak gen-src gen-views                        <4>
----
<1> Create a directory to hold your Yaktor application.
<2> Change into the Yaktor application directory.
<3> Initialize a new Yaktor application in the current directory using the `yaktor/node` image.
<4> Use the `./yak` command to generate source & views.

TIP: You can issue command `./yak` by itself to get help.

At this point, simply open a text editor in directory `yakapp` and start poking around the code, or you can <<starting,start & view your app>> in action.

TIP: You should consider using our {eclipseplugin}, which includes an intelligent editor for the <<yaktor-domain-specific-languages,Yaktor DSLs>>.

===== New native Yaktor project
[source,sh]
----
$ mkdir yakapp                                 <1>
$ cd yakapp                                    <2>
$ npm install yaktor && $(npm bin)/yaktor init <3>
$ npm run gen-src gen-views                    <4>
----
<1> Create a directory to hold your Yaktor application.
<2> Change into the Yaktor application directory.
<3> Initialize a new Yaktor application in the current directory.
<4> Generate source & views.

At this point, simply open a text editor in directory `yakapp` and start poking around the code, or you can <<starting-natively,start & view the app>> in action.

TIP: You should consider using our {eclipseplugin}, which includes an intelligent editor for the <<yaktor-domain-specific-languages,Yaktor DSLs>>.

==== Coming aboard an existing Yaktor project
If you're using Docker to work on an existing Yaktor project, see <<onboarding-with-docker,onboarding with Docker>>.

If you're running an existing Yaktor project natively, see <<onboarding-natively,onboarding natively>>.

===== Onboarding with Docker
[source,sh]
----
$ git clone ...           <1>
$ cd ...                  <2>
$ ./yak gen-src gen-views <3>
----
<1> Clone the source repository containing the Yaktor application via git, svn, etc.
<2> Change into the Yaktor application directory.
<3> Use the `yak` command to generate source & views.

At this point, simply open a text editor in your source directory and start poking around the code, or you can <<starting-with-docker,start & view the app>> in action.

TIP: You should consider using our {eclipseplugin}, which includes an intelligent editor for the <<yaktor-domain-specific-languages,Yaktor DSLs>>.

===== Onboarding natively
[source,sh]
----
$ git clone ...             <1>
$ cd ...                    <2>
$ npm install               <3>
$ npm run gen-src gen-views <4>
----
<1> Clone the source repository containing the Yaktor application via git, svn, etc.
<2> Change into the Yaktor application directory.
<3> Install node modules.
<4> Generate source & views.

At this point, simply open a text editor in your source directory and start poking around the code, or you can <<starting-natively,start & view the app>> in action.

TIP: You should consider using our {eclipseplugin}, which includes an intelligent editor for the <<yaktor-domain-specific-languages,Yaktor DSLs>>.

=== Starting
This section describes how to start & view a Yaktor-based application.
This will be done either by <<starting-with-docker,using Docker>> or <<starting-natively,running natively>>.

==== Starting with Docker
If you're using Docker, then starting your application, assuming you've already <<writing-code,generated source & views>>, is as easy as

[source,sh]
----
$ ./yak start
----

TIP: If you add _literally_ `./node_modules/.bin` to your `PATH`, you won't have to include the `./` prefix to `./yak` anymore.

At this point, you are ready to begin editing your Yaktor application.  It's crucial that you understand <<yaktor-domain-specific-languages,Yaktor's DSLs>> and <<technology-specific-mappings,technology mappings>>, so make sure you <<yaktor-domain-specific-languages,check them out>>.

==== Starting natively
If you're running natively, assuming you've already <<writing-code,generated source & views>>, starting your application is achieved with

[source,sh]
----
$ npm run start
----

At this point, you are ready to begin editing your Yaktor application.  It's crucial that you understand <<yaktor-domain-specific-languages,Yaktor's DSLs>> and <<technology-specific-mappings,technology mappings>>, so make sure you <<yaktor-domain-specific-languages,check them out>>.

== Part III. Overview of Yaktor Domain-Specific Languages & Technology Mappings
This section only describes the high-level concepts behind a Yaktor application.
For a comprehensive treatment, see XXX.

=== Yaktor domain-specific languages
Yaktor includes two domain-specific languages (DSLs) used to capture & express much of your business domain's data & logic.
These DSLs enable Yaktor to remain independent of the underlying implementation technology.
They serve as input not only to generate the application's implementation using a particular technology stack, but also to generate incredibly useful documentation, even for nontechnical business analysts, which is one of Yaktor's great strengths.

IMPORTANT:  Yaktor includes code generation features in order to support rapid application development.
One of the key design feature's of Yaktor's code generation facilities is to explicitly accommodate custom code.
As such, _Yaktor will always preserve your code customizations._

Yaktor's DSLs consist of

* a <<yaktor-domain-modeling-dsl,domain modeling language>>, and
* a <<yaktor-conversation-dsl,conversation language>>.

Both languages, like most DSLs, are declarative in nature, not imperative.
In other words, they don't describe _how_ something is implemented, they describe _what_ is to be implemented.
It is very useful to think of them as a _specification_ of data structures & conversational behavior, respectively.

==== Yaktor domain modeling DSL
Yaktor supports the definition of a canonical information model, which Yaktor calls a _domain model_.
In a Yaktor-based application, the domain model is intended to be composed of data structures, called _entitities_, that

* have an id,
* are persisted to a datastore,
* have primarily schema-oriented validation logic, and
* are devoid of behaviorally rich business logic.

Having said that, Yaktor does allow you to add arbitrary instance & static methods to your entities, but that must be done in the language of your current Yaktor technology mapping, due to the aforementioned declarative & technology-agnostic nature of Yaktor's DSLs.

The key point here is that the _state of your business data_ is described by Yaktor's domain modeling DSL.

IMPORTANT: Yaktor domain models are optional; you can author Yaktor applications with no underlying entities if you so choose.

NOTE: For more information on Yaktor's domain modeling DSL, see <<yaktor-domain-model-dsl-reference>>.

==== Yaktor conversation DSL
In a Yaktor-based application, much (but not necessarily _all_) of the application's behavior is manifested conceptually as _conversations_.
Conversations are just what you might intuit: a collaboration between multiple parties (called _agents_) on some topic (usually a data _type_).

The key point here is that the _behavior_ of your application is described primarily by Yaktor's conversation DSL.
For now, just know that the conversation DSL provides for the specification of a collection of _types_, _endpoints_ (like REST endpoints), and _agents_.
Agents may have _state machines_ and may source & sink _events_.

NOTE: For more information on Yaktor's conversation DSL, see <<yaktor-conversation-dsl-reference>>.

=== Technology-specific mappings
Since Yaktor is based on technology-agnostic, declarative DSLs, it needs to eventually _do_ something.
To do something, you have to have an implementation using some technology stack.
In Yaktor, a _technology mapping_ is what provides that.

While Yaktor was prototyped initially with a {springroo} mapping, the current primary (and only supported) mapping is {nodejs}.

Writing a technology mapping is a big deal.
The Yaktor team, due to limited resources, chose to focus on a {nodejs} stack, using {javascript} (ok, _ECMAScript_) & including {express}, {mongodb} & {mongoose}.
However, the team will continue to consider other mappings, in particular, {springboot}, {akka}/{scala}, and others.

NOTE: Although it would be ambitious, anyone could create a Yaktor technology mapping.

==== Node.js mapping
The {nodejs} mapping is Yaktor's primary mapping.  This section attempts to give a brief treatment of a project's <<source-organization, source organization>> & how the Node.js code generation technique supports <<code-customization, code customization>>.

NOTE: See <<TODO,here>> for the full Yaktor {nodejs} mapping reference.

===== Source organization


== Part IV. Yaktor Architecture

=== Software agents
TODO: briefly describe agents (& their predecessors, actors, here)

=== State machines
TODO: briefly describe a state machine

=== Lambda architecture
TODO: briefly describe the lambda architecture & provide pointers.

==== Event stream
TODO: briefly describe how Yaktor events & messages are processed.

==== Data persistence
TODO: briefly describe how domain models are persisted.

=== Core platform
TODO: briefly describe the features of the core platform.

=== Feature-based modules

==== Authorization

==== Event streaming

== Part V. Yaktor DSL Reference

=== Yaktor domain model DSL reference

=== Yaktor conversation DSL reference
