:sectanchors:
:icons: font
:toclevels: 3

= Conversation Artifacts and Concepts

== Introduction

A conversation is comprised of a definition as specified in the link:languageReference.html[Language Reference]
 as well as link:#generated-source[generated source], link:#generated-metadata[metadata], and runtime modules. In this document we will discuss the two later in detail.
 
== Generated Source

There are several stages of artifact generation but this document will focus on the primary source artifact. 
These include all artifacts generated by the eclipse plugin. UI artifacts are discussed in link:engineUI.html[Engine UI]

The general pattern for generate artifacts is, as much as possible, to use the generation gap pattern (GGP).
In the .js world this will result in a named triplet (i.e. index.js index.gen.js and index.def.js), 
of which a single _primary source_ is to be assumed. 

In that:

* All triplets are generally given the same meaning.
* xxx.js file is the primary source
** This file is only touched by the generator if it doesn't exit.
** If any modification or customization are to occur they will happen here
** It is to be though of as a concrete subclass in JAVA.
* xxx.def.js is the default implementation of extension point(s).
** This file will be overwritten every time the generator runs.
** This file changes as features of xxx are added or removed.
** To extend the default behavior find the closure you want to alter and copy its defintion into the primary source.
** Think of this file as an abstract subclass of some interface contract.
* xxx.gen.js  
** This file will be overwritten every time the generator runs.
** This file often contains structural features which are not intended to be altered.

Also you may find instances where only a primary source is generated. 
This may be because no extension is possible, in which case the file will not retain your changes.

=== Conversations/js/<CONVERSATION>/

This is the default location for most of the conversation and agent related artifacts.
Each conversation file will result in a new sub directory specified in your conversation.

==== index.js

This file has no meaningful extension points. Its purpose is to inform the runtime of important 
configuration such as valid states and transitions as well as provide the init function.

This file is loaded with with above information for all agents defined and imported by a conversation.
All of the necessary downstream files are woven into this file via +require+ statements.

==== <AGENT>/lib/states.js

State files include all of the (nonstructural) business logic of the agent. 
Mainly the state and transition +IMPL+ and +decision+ code (closures) will be written here. 
If the structure of your agent changes your closures may become out-dated or unreachable, so it 
it is important to maintain your code. The runtime will consult the contents of this file before and
during every event for an agent looking for default and override code. However it will not execute code
which it does not expect to find based on the structure define in link:#index-js[index.js].

[source,javascript]
.states.js
----
"use strict";                                                   // <1>
var util = require('util');
var my = module.exports = require("./states.gen.js")
util._extend(my,require("./states.def.js"));

my.adjust.on=function(meta,data,done){                          // <2>
  var results = {"adjustment":"adjustment","signal":"signal"};  // <3>
  done(null,data,Object.keys(results)[0]);                      // <4>
}
/**
 * While in adjust.
 * adjustment -> running > sync
 */
my.adjust.transitions["adjustment"].handler=
    function(causedByEventName,meta,data,done){                 // <5>
  done(null,data);
};
----
<1> First 4 lines are the default stub of GGP 
<2> Closure for agent entering the +adjust+ state
<3> Set of valid events to trigger
<4> calling the callback choosing the first event
<5> Closure for adjustment transition in the adjust state

==== rest/endpoints/<PATH>/<TYPE>.js

When you define a resource you will get a (potentially nested according to PATH) file named after the +type+.
This file triplet is missing <TYPE>.gen.js because it is basically all customizable.
Frequently you may need to override the behavior if your +type+ needs to be manually parsed before persisting.

[source,javascript]
.Thing.js
----
"use strict";
var util = require('util');
var my = module.exports = require("./Thing.def.js")

var OtherThing = require("mongoose").model("OtherThing")  // <1>
  , conversation = require("conversation")
  , converter = conversation.converter;

/*
 * update
 * PUT /thing/:id
 * for Thing
 * Optionally module.exports.updateMiddleware = [function...]||function;
 */
module.exports.update = function(id, body,req, res) {
  converter.from('cName.OtherThing',
      body.other,   // <2>
      function(err,domain){
    OtherThing.findOneAndUpdate({_id:id},domain,{new:true},function(mError,saved){
      converter.to('cName.OtherThing',saved,function(err,data){
        err = mError||err;
        Response.update(req,res,"application/json")(err,data);
      });
    });
  });
}
----
<1> header section copied from Thing.def.js. Modifed to reference +model("OtherThing")
<2> contrived reference to body.other instead of body to demonstrate an customization of persistance.

=== public/

Some api stuff.

==== api/<CONVERSATION>/<AGENT>.js

This source is not intended to be modified but rather act as a JavaScript api for accessing the runtime's async behavior.
Every agent has one. It depend on link:public-socketApi-js[socketApi.js]

[source.js]
.conversations/ejs/<CONVERSATION>/test.js
----
...

for(var onV in agentApi.socket.on){  // <1>
  (function(on){
    if(/state:.*/.test(on)){
      agentApi.socket.on[on](        // <1>
        sessionId,json,function(){
        
          ...
        
        }
      )
    }
  })(onV);
}

...
----
<1> Using <AGENT>.js


==== socketApi.js

Used to connect a js environment to the runtime's async behavior.

[source.js]
.conversations/ejs/<CONVERSATION>/test.js
----
...

var sessionId = "<%=sId%>";
socketApi.connect(sessionId,true,function(){     // <1>
  if(inited[sessionId]){
    console.log("Re-initing: %s",'Activator');
    var json = JSON.parse($('#CareConsole_Activator_init_input').val());
    agentApi.socket.emit.init(sessionId,json);
  }
});

...
----
<1> Using socketApi.js

== Metadata

Tangential to source is metadata. It is generated for the purpose of down steam generators like engine-ui or 
for other runtime like simulators.


